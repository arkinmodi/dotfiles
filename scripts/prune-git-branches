#!/usr/bin/env python3
from __future__ import annotations

import argparse
import subprocess


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('--dry-run', action='store_true')
    parser.add_argument('--force', action='store_true')
    args = parser.parse_args()

    current_branch = subprocess.run(
        ['git', 'branch', '--show-current'],
        capture_output=True,
        encoding='UTF-8',
    )

    subprocess.run(['git', 'fetch', '--all', '--prune', '--quiet'])

    upstreams = subprocess.run(
        ['git', 'remote', 'show'],
        capture_output=True,
        encoding='UTF-8',
    )

    if not upstreams.stdout:
        print('No remotes configured!')
        return 1

    origin_info = subprocess.run(
        ['git', 'symbolic-ref', '--short', 'refs/remotes/origin/HEAD'],
        capture_output=True,
        encoding='UTF-8',
    )

    if origin_info.returncode:
        origin_head_not_set_error = 'fatal: ref refs/remotes/origin/HEAD is '\
            'not a symbolic ref\n'

        if origin_info.stderr == origin_head_not_set_error:
            # could also run `git remote set-head origin main` if
            # main is the default branch
            print(
                'origin default branch not set! Try running:\n'
                'git remote set-head origin --auto'
            )
        else:
            print(
                "Failed to get info on origin's default branch! "
                f'Error: {origin_info.stderr}'
            )
        return 1

    default_branch = origin_info.stdout.splitlines()[0].removeprefix('origin/')
    subprocess.run(['git', 'switch', default_branch, '--quiet'])
    subprocess.run(['git', 'pull', '--all', '--prune', '--quiet'])

    upstream_branches = set()
    for remote in upstreams.stdout.splitlines():
        remote_refs = subprocess.run(
            [
                'git',
                'for-each-ref',
                "--format='%(refname:lstrip=3)'",
                f'refs/remotes/{remote}',
            ],
            capture_output=True,
            encoding='UTF-8',
        )
        upstream_branches.update(
            [rr[1:-1] for rr in remote_refs.stdout.splitlines()],
        )
    upstream_branches.discard('HEAD')

    head_refs = subprocess.run(
        [
            'git',
            'for-each-ref',
            "--format='%(refname:lstrip=2)'",
            'refs/heads/',
        ],
        capture_output=True,
        encoding='UTF-8',
    )
    local_branches = {hr[1:-1] for hr in head_refs.stdout.splitlines()}
    victims = local_branches.difference(upstream_branches)

    if args.dry_run:
        print('Deleting branches:')
        for branch in victims:
            print(branch)
    elif len(victims):
        op = ['git', 'branch', '--delete']
        if args.force:
            op.append('--force')
        git_delete = subprocess.run([*op,  *victims])

        if git_delete.returncode != 0:
            print('\nNot all branches were deleted. Try running with --force.')

    subprocess.run(
        [
            'git',
            'switch',
            '--quiet',
            current_branch.stdout.splitlines()[0],
        ],
        capture_output=True,
    )

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
